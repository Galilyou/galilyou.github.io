---
layout: post
title: 'A Quick Tip: The Different Classes Of Algorithms'
date: '2010-01-14T16:23:00.000+02:00'
author: Galilyou
tags:
- Algorithms
modified_time: '2010-01-14T16:32:52.807+02:00'
thumbnail: http://1.bp.blogspot.com/_CvP3b8RZYyc/S08ebgdliaI/AAAAAAAAADk/doCvgOon5zA/s72-c/x12-semi-log.gif
blogger_id: tag:blogger.com,1999:blog-5568328146032664626.post-91624821943193232
blogger_orig_url: http://www.galilyou.com/2010/01/quick-tip-different-classes-of.html
---

Algorithms are the heart of computer science. They are the thoughts, the ideas, and the most fun part of this industry. Scientists categorize the various known algorithms into 4 classes: Logarithmic, Linear, Quadratic and Exponential. Let's look at those briefly:<br />1- Logarithmic Algorithms:<br />&nbsp;&nbsp; This type is the fastest of those 4 classes. It has a run curve that looks something like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_CvP3b8RZYyc/S08ebgdliaI/AAAAAAAAADk/doCvgOon5zA/s1600-h/x12-semi-log.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/_CvP3b8RZYyc/S08ebgdliaI/AAAAAAAAADk/doCvgOon5zA/s320/x12-semi-log.gif" /></a><br /></div><br /><div class="separator" style="clear: both; text-align: center;"><br /></div>Where the x here is the number of items to be processed by the algorithm, and y is the time takes by the algorithm. As you can see from the figure, the time taken increases&nbsp;slowly when the number of items to be processed increase. Binary Search is a perfect example for a logarithmic algorithm. If you recall, binary search, divides the array into two halves and excludes one half each time it does a search. Here's a code example of binary search implementation in C#:<br /><pre class="csharp" name="code">bool BSearch(int[] list, int item, int first, int last)<br />{<br /> if(last - first &lt; 2)<br />             return list[first] == item || list[last] == item;<br />             <br />        int mid = (first + last)/2;<br />        if(list[mid] == item)<br />             return true;<br />             <br />        if (list[mid] &gt; item)<br />                return BSearch(list, item, first, mid - 1);<br /> <br /> return BSearch(list, item, mid + 1, last);<br />}<br /></pre><br />2- Linear Algorithms:<br />&nbsp;&nbsp;Runs in time, linear to the input items. It's curve looks like the following:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_CvP3b8RZYyc/S08i6pcYYyI/AAAAAAAAADs/sL9iubT27IY/s1600-h/linear.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/_CvP3b8RZYyc/S08i6pcYYyI/AAAAAAAAADs/sL9iubT27IY/s320/linear.png" /></a><br /></div><br /><br />A linear search is a typical example of that, where one would traverse the array or, whatever data structure, item by item. An implementation of linear search looks like this:<br /><br /><pre class="csharp" name="code">bool LinearSearch(int[] list, int item)<br />{<br />     for(int i = 0; i &lt; list.Length; i++)<br />          if(list[i] == item)<br />              return true;<br />        return false;<br />}<br /></pre>3- Quadratic Algorithm: &nbsp;&nbsp; This one runs time grows to to the power of 2, with each increase in the input sizes, which means while processing 2 items the algorithm will do 4 steps, 3 items will take 9 steps, 4 items will take 16 steps, etc. The next figure shows how a quadratic curve might look like: <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_CvP3b8RZYyc/S08j5CVWiGI/AAAAAAAAAD0/liMvQSqgBBU/s1600-h/quadratic.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/_CvP3b8RZYyc/S08j5CVWiGI/AAAAAAAAAD0/liMvQSqgBBU/s320/quadratic.png" /></a> <br /></div><br />A famous example of an algorithm with quadratic growth is Selection Sort: <br /><br /><pre class="csharp" name="code">void SelectionSrot(int[] list)<br />{<br />            int i, j;<br />            int min, temp;<br /><br />            for (i = 0; i &lt; list.Length - 1; i++)<br />            {<br />                min = i;<br /><br />                for (j = i + 1; j &lt; list.Length; j++)<br />                {<br />                    if (list[j] &lt; list[min])<br />                    {<br />                        min = j;<br />                    }<br />                }<br /><br />                temp = list[i];<br />                list[i] = list[min];<br />                list[min] = temp;<br />            }<br />}<br /></pre><br />4- Exponential Algorithm:<br />This is the super slow of this list of four. It grows exponentially (that is, for 2 items it takes 2 ^ 2, for 3 items it takes 2^3, for 4 items it takes 2 ^ 4, etc.<br />Again algorithms are the key to computer science, the most fun part of programmer's &nbsp;job. Choose your algorithms carefully and always try to improve.<br /><br />Hope this helps.
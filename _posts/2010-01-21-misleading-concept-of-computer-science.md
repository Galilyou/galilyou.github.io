---
layout: post
title: 'A Misleading Name of Computer Science Concept: Dynamic Programming'
date: '2010-01-21T15:22:00.000+02:00'
author: Galilyou
tags:
- Algorithms
- dynamicProgramming
modified_time: '2010-02-01T13:09:00.084+02:00'
thumbnail: http://4.bp.blogspot.com/_CvP3b8RZYyc/S1hWDUQQtZI/AAAAAAAAAE8/NVWnG9ZMkXA/s72-c/output.png
blogger_id: tag:blogger.com,1999:blog-5568328146032664626.post-7769892905223391217
blogger_orig_url: http://www.galilyou.com/2010/01/misleading-concept-of-computer-science.html
---

Have you heard of these words before?<br />Probably yes!<br />First let's make a clear (well, not so clear) difference, clearer. Dynamic Programming is not about Dynamic Typing. Dynamic typing is a property of &nbsp;a particular programming language. Languages like Lisp, Python, and Ruby are all dynamically typed languages. Unlike those, languages like C/C++, Java, and C# are statically typed language. The difference relies on whether the compiler checks certain things (types, overload resolution, etc.) &nbsp;before running the program or not.<br />Dynamic Programming on the other hand is something very different. It's an ancient method for solving problems by basically dividing these problems into smaller, and easier to solve problems.<br /><br />It's mainly focused on addressing these two issues:<br /><br /><ol><li>Overlapping subproblems&nbsp;</li><li>Optimal Substructures</li></ol><div>I think the best way to explain these two fuzzy concepts is by using examples. To start let's see an example of using a famous dynamic programming technique called &nbsp;Memorization.&nbsp;Assume that we need to implement a function that calculates a&nbsp;<a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci&nbsp;</a>sequence. I know this is easy, but let's look at this first implementation:</div><pre class="csharp" name="code">static int FibClassic(int n, ref int numberOfStepsTaken)<br />        {<br />            numberOfStepsTaken += 1;<br />            if (n &lt;= 1)<br />                return 1;<br />            Console.WriteLine("FibClassic called with: {0}", n);<br />            return FibClassic(n - 1, ref numberOfStepsTaken) + FibClassic(n - 2, ref numberOfStepsTaken);<br />        }<br /></pre>Note: on the above code I used two counter variables to count the number of times the method executed. I also printed the input on which the method is called&nbsp;every time, just to give you a hint of how dividing a problem can cause the same subproblem to be computed more than once --Subproblem Overlapping, remember! Now let's run the code given the number 6 as input and see what happens: <br /><pre class="csharp" name="code">int z = 0;<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int x = FibClassic(6, ref z);<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine("{0}: {1}", x, z);</pre><div class="separator" style="clear: both; text-align: center;"><br /></div>And here's the result of this call:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_CvP3b8RZYyc/S1hWDUQQtZI/AAAAAAAAAE8/NVWnG9ZMkXA/s1600-h/output.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://4.bp.blogspot.com/_CvP3b8RZYyc/S1hWDUQQtZI/AAAAAAAAAE8/NVWnG9ZMkXA/s640/output.png" width="640" /></a></div><br />As you can see the method has been called first with input 6 which is the initial input we passed in, then 5, 4, 3, &nbsp;2, 2, ... oops!! Can you spot it? the method is being called on the same input more than once! Think about this for a while, pretty logical, yeah!? Our strategy is based on dividing the problem into simpler subproblems. For example to get the 6th item in the Fibonacci sequence we divide the problem into two smaller problems, getting the 5th item, and 4th item and adding them together, then to get the 5th, you should get the 4th and 3rd, etc. The next figure shows how is this working.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_CvP3b8RZYyc/S1hV0VZHvcI/AAAAAAAAAE0/dbF7i0TzTYY/s1600-h/tree.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="196" src="http://3.bp.blogspot.com/_CvP3b8RZYyc/S1hV0VZHvcI/AAAAAAAAAE0/dbF7i0TzTYY/s400/tree.png" width="400" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><br /></div>As you notice the overlapping happens when solving one part of the problem includes solving another part of the problem, in such a case we can take advantage of this and simply memorize the solution for the overlapped problem and each time we need that result, we don't have to compute it again, we just supply it from wherever we stored it. Here's the modified method to do it: <br /><pre class="csharp" name="code">static int FibFast(int n, ref int numberOfStepsTaken, Dictionary<int, int=""> store)</int,><br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numberOfStepsTaken += 1;<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (n &lt;= 1)<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 1;<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!store.ContainsKey(n))<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;store[n] = FibFast(n - 1, ref numberOfStepsTaken, store) + FibFast(n - 2, ref numberOfStepsTaken, store);<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return store[n];<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br /><br /></pre>If you run that same method on the same input (6) you should get 13 as the result (the same old result) but the number of iterations would be 11 which is about half the number of iterations the first method take. This doesn't seem to be a very huge enhancement, but let's see how the two methods act for bigger numbers.  Running the first method of input equals to 30 we get the result &nbsp;1346269 and number of iterations &nbsp;2692537. Now running the second method on the same input (30) we get the result 1346269 -which is the same result- and number of iterations 59!  That's a <b>HUGE </b>difference!<br /><br /><b>Now back to core, what does this have to do with the term Dynamic Programming??</b><br /><i><b></b></i><i><span class="Apple-style-span" style="color: blue;">Actually, it's a very misleading term, historically it was invented by a mathematician called </span><b><span class="Apple-style-span" style="color: blue;">Bellmen </span></b><span class="Apple-style-span" style="color: blue;">and he was at the time being paid by the US defense department to work on something else. He didn't want&nbsp;them to know what he was doing, so he made up &nbsp;a name that he was sure it has no clue what it actually meant. Now we have to live with this forever :)</span></i>
---
layout: post
title: List.Find(Predicate <T>) Considered Harmful
date: '2010-07-06T12:26:00.000+03:00'
author: Galilyou
tags: 
modified_time: '2010-07-06T20:21:04.819+03:00'
blogger_id: tag:blogger.com,1999:blog-5568328146032664626.post-5829856647979998780
blogger_orig_url: http://www.galilyou.com/2010/07/listfindpredicate-considered-harmful.html
---

Hold on, it's not goto! <br /><br />I dare to say that every program have ever written on this entire planet needed some sort of searh functionality, and if it didn't, it's probably because it's too lame and frickin' uslelss. <br /><br />Today I was working on a piece of code that part of it is concerned about finding items in a generic List&lt;T&gt;. The code I wrote was some like this: <br /><br /><pre name="code" class="csharp">var products = ProductsCollection.Find(p => p.Price > 500);<br /></pre><br />Doesn't that look concise and elegant. For me it does, the problem is, however, this code is not <i><b>SAFE</b></i> (yeah, i was surprised too). <br /><br />When I run this code I got a <a href="http://msdn.microsoft.com/en-us/library/system.nullreferenceexception.aspx">System.NullReferenceException</a>. WTF is that? ProductsCollection is totally a valid reference, however, it was empty.<br /><br />OK, wait a second why should searching an empty list throw an exception? The expected result should be null or something but not an exception. After thinking about it a little, I thought, Oh, what if the list contains value types? In such case null is not a valid return type, so an exception makes sense to me now. <br /><br />Here I thought I really got it and understood that List.Find will throw a null reference exception if called on an empty list. I was totally wrong if you must know. The call would simply return default(T) which is null for reference types. The exception was actually thrown when I used the return of the find! <br /><br />Now I wondered "OK, now what if i'm searching a list that only contains value types and the item i'm searching for doesn't exist in that list? What would be the result in this case? Well, let's try it out":<br /><br /><pre name="code" class="csharp">List&lt;int&gt; evens = new List&lt;int&gt; { 0, 2, 4, 6, 8, 10};<br />var evenGreaterThan10 = evens.Find(e => e > 10);<br />Console.WriteLine(evenGreaterThan10);<br /></pre><br />What the search returned in this case is the value 0, yes zero! because nothing in the list is greater than 10 so Find will just give you default(T). This can lead to some really nasty bugs. Don't curse, this is frickin' documented you lazy sloths.<br /><i><br /><b>Important Note:</b><br />When searching a list containing value types, make sure the default value for the type does not satisfy the search predicate. Otherwise, there is no way to distinguish between a default value indicating that no match was found and a list element that happens to have the default value <br />for the type. If the default value satisfies the search predicate, use the FindIndex method instead.<br /></i><br /><br />Trying to be safe in this case you could simply check after finding to see if the returned value is what you actually asked for, something like that: <br /><br /><pre class="csharp" name="code">List&lt;int&gt; evens = new List&lt;int&gt; { 0, 2, 4, 6, 8, 10};<br />var evenGreaterThan10 = evens.Find(e => e > 10);<br />if(evenGreaterThan10 > 10)<br />{<br />   // valid value<br />}<br />else <br />{<br />   // none found    <br />}<br /></pre><br />I'm not sure how do you feel about that, but for me, I really hate it! So what I ended up doing is something similar to the well known TryParse style, I overloaded the Find method with an extension method that would allow the usage to be something like this:<br /><br /><pre class="csharp" name="code">List&lt;int&gt; evens = new List&lt;int&gt; { 0, 2, 4, 6, 8, 10};<br />int i;<br />if(evens.Find(e => e > 6, out i))<br />  Console.WriteLine(i);<br />else <br />  Console.WriteLine("None found");<br /></pre><br />The extension method is as simple as: <br /><br /><pre class="csharp" name="code">public static bool Find&lt;T&gt;(this List&lt;T&gt; list, Predicate&lt;T&gt; predicate, out T output)<br />{<br />  output = list.Find(predicate);<br />  return predicate(output);<br />}<br /></pre><i><br /><b>EDIT:</b><br />As reported by Kevin Hall in the comment, this method has a serious bug. Consider the following code segment: <br /><pre class="csharp" name="code">List&lt;int&gt; x = new List&lt;int&gt; { -10, -8, -6, -4 };<br />int myResult = -9999;<br />bool resultFound = x.Find(e => e > -3, out myResult);<br /></pre><br />In this case result found would be true and myResult would be zero! A yet better way to do this is by making use of the FindIndex method like so: <br /><br /><pre class="csharp" name="code">public static bool Find&lt;T&gt;(this List&lt;T&gt; list, Predicate&lt;T&gt; predicate, out T output)<br />{<br />  int index = list.FindIndex(predicate);<br />  if (index != -1)<br />  {<br />    output = list[index];<br />    return true;<br />  }<br />  output = default(T);<br />  return false;<br />}<br /></pre><br />Thanks Kevin for pointing that out.<br /></i><br />I'm much happier now, I can drop the suicide thought for a while! What do you think dear reader?